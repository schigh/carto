![carto](./_img/carto.png)

Carto is a command line tool that can help you make typed Go maps quickly and easily.  

```
> carto --help
```

```
C A R T O

üåê Maps made easy

usage:
carto -p <package> -s <structname> -k <keytype> -v <valuetype> [options]

-p    (string)      Package name (required)
-s    (string)      Struct name  (required)
-k    (string)      Key type     (required)
-v    (string)      Value type   (required)
-r    (string)      Receiver name (defaults to lowercase first char of
                    struct name)
-o    (string)      Output file path (if omitted, prints to STDOUT)
-b    (bool)        "Get" return signature includes a bool value indicating
                    if the key exists in the internal map
-d    (bool)        "Get" signature has second parameter for default return
                    value when key does not exist in the internal map
-lz   (bool)        Will lazy-instantiate the internal map when a write
                    operation is used
-version            Print version and exit
```

## Getting Carto

You can install carto by using `go get`

```
> go get -u github.com/schigh/carto
```

```
> carto -version
> CARTO version: 0.0.1
```

## Options

* `p` (string, required) - The package of the generated struct

* `s` (string, required) - The name of the generated struct

* `k` (string, required) - The key type (see below regarding key and value syntax)

* `v` (string, required) - The value type (see below regarding key and value syntax)

* `r` (string) - The receiver name.  By default, it is the lowercase first letter of the generated struct name

* `o` (string) - Output file.  By default, carto prints to STDOUT

* `b` (bool) - `Get` will return an additional boolean value indicating whether or not the value was found within the internal map
* `d` (bool) - `Get` will take an additional default value to be returned if no value exists for the specified key
* `lz` (bool) - The generated struct will lazily (via  `sync.Once`) instantiate its internal map

## Examples

A struct `MyMap` that wraps `map[string]*zerolog.Logger`:

```
> carto -p foo -s MyMap -k string -v '*github.com/rs/zerolog.Logger'
```
<details>
<summary>Generated Source</summary>
<p>

```go
// Code generated by github.com/schigh/carto.  DO NOT EDIT.
package foo

import (
	"sync"

	"github.com/rs/zerolog"
)

// MyMap wraps map[string]*zerolog.Logger, and locks reads and writes with a mutex
type MyMap struct {
	mx   sync.RWMutex
	impl map[string]*zerolog.Logger
}

// NewMyMap generates a new MyMap with a non-nil map
func NewMyMap() *MyMap {
	m := &MyMap{}
	m.impl = make(map[string]*zerolog.Logger)

	return m
}

// Get gets the *zerolog.Logger keyed by string.
func (m *MyMap) Get(key string) (value *zerolog.Logger) {
	defer m.mx.RUnlock()
	m.mx.RLock()

	value = m.impl[key]

	return
}

// Keys will return all keys in the MyMap's internal map
func (m *MyMap) Keys() (keys []string) {
	defer m.mx.RUnlock()
	m.mx.RLock()

	keys = make([]string, len(m.impl))
	var i int
	for k := range m.impl {
		keys[i] = k
		i++
	}

	return
}

// Set will add an element to the MyMap's internal map with the specified key
func (m *MyMap) Set(key string, value *zerolog.Logger) {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.impl[key] = value
}

// Absorb will take all the keys and values from another MyMap's internal map and
// overwrite any existing keys
func (m *MyMap) Absorb(otherMap *MyMap) {
	defer otherMap.mx.RUnlock()
	defer m.mx.Unlock()
	m.mx.Lock()
	otherMap.mx.RLock()

	for k, v := range otherMap.impl {
		m.impl[k] = v
	}
}

// AbsorbMap will take all the keys and values from another map and overwrite any existing keys
func (m *MyMap) AbsorbMap(regularMap map[string]*zerolog.Logger) {
	defer m.mx.Unlock()
	m.mx.Lock()

	for k, v := range regularMap {
		m.impl[k] = v
	}
}

// Delete will remove a *zerolog.Logger from the map by key
func (m *MyMap) Delete(key string) {
	defer m.mx.Unlock()
	m.mx.Lock()

	delete(m.impl, key)
}

// Clear will remove all elements from the map
func (m *MyMap) Clear() {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.impl = make(map[string]*zerolog.Logger)
}

// Value returns a copy of the underlying map[string]*zerolog.Logger
func (m *MyMap) Value() map[string]*zerolog.Logger {
	defer m.mx.RUnlock()
	m.mx.RLock()

	out := make(map[string]*zerolog.Logger, len(m.impl))
	for k, v := range m.impl {
		out[k] = v
	}

	return out
}

// Size returns the number of elements in the underlying map[string]*zerolog.Logger
func (m *MyMap) Size() int {
	defer m.mx.RUnlock()
	m.mx.RLock()

	return len(m.impl)
}

```

</p>
</details>

The previous struct, lazy-instantiated:

```
> carto -p foo -s MyMap -k string -v '*github.com/rs/zerolog.Logger' -lz
```
<details>
<summary>Generated Source</summary>
<p>

```go
// Code generated by github.com/schigh/carto.  DO NOT EDIT.
package foo

import (
	"sync"

	"github.com/rs/zerolog"
)

// MyMap wraps map[string]*zerolog.Logger, and locks reads and writes with a mutex
type MyMap struct {
	mx        sync.RWMutex
	impl      map[string]*zerolog.Logger
	onceToken sync.Once
}

// Get gets the *zerolog.Logger keyed by string.
func (m *MyMap) Get(key string) (value *zerolog.Logger) {
	defer m.mx.RUnlock()
	m.mx.RLock()

	value = m.impl[key]

	return
}

// Keys will return all keys in the MyMap's internal map
func (m *MyMap) Keys() (keys []string) {
	defer m.mx.RUnlock()
	m.mx.RLock()

	keys = make([]string, len(m.impl))
	var i int
	for k := range m.impl {
		keys[i] = k
		i++
	}

	return
}

// Set will add an element to the MyMap's internal map with the specified key
func (m *MyMap) Set(key string, value *zerolog.Logger) {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]*zerolog.Logger)
	})
	m.impl[key] = value
}

// Absorb will take all the keys and values from another MyMap's internal map and
// overwrite any existing keys
func (m *MyMap) Absorb(otherMap *MyMap) {
	defer otherMap.mx.RUnlock()
	defer m.mx.Unlock()
	m.mx.Lock()
	otherMap.mx.RLock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]*zerolog.Logger)
	})
	for k, v := range otherMap.impl {
		m.impl[k] = v
	}
}

// AbsorbMap will take all the keys and values from another map and overwrite any existing keys
func (m *MyMap) AbsorbMap(regularMap map[string]*zerolog.Logger) {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]*zerolog.Logger)
	})
	for k, v := range regularMap {
		m.impl[k] = v
	}
}

// Delete will remove a *zerolog.Logger from the map by key
func (m *MyMap) Delete(key string) {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.onceToken.Do(func() {
		m.impl = make(map[string]*zerolog.Logger)
	})
	delete(m.impl, key)
}

// Clear will remove all elements from the map
func (m *MyMap) Clear() {
	defer m.mx.Unlock()
	m.mx.Lock()

	m.impl = make(map[string]*zerolog.Logger)
}

// Value returns a copy of the underlying map[string]*zerolog.Logger
func (m *MyMap) Value() map[string]*zerolog.Logger {
	defer m.mx.RUnlock()
	m.mx.RLock()

	out := make(map[string]*zerolog.Logger, len(m.impl))
	for k, v := range m.impl {
		out[k] = v
	}

	return out
}

// Size returns the number of elements in the underlying map[string]*zerolog.Logger
func (m *MyMap) Size() int {
	defer m.mx.RUnlock()
	m.mx.RLock()

	return len(m.impl)
}

```

</p>
</details>

With a default return value:

```
> carto -p foo -s MyMap -k string -v '*github.com/rs/zerolog.Logger' -d
```
<details>
<summary>Generated Source (<code>Get</code> func)</summary>
<p>

```go
...

// Get gets the *zerolog.Logger keyed by string.  If the key does not exist, a default *zerolog.Logger will be returned
func (m *MyMap) Get(key string, dflt *zerolog.Logger) (value *zerolog.Logger) {
    defer m.mx.RUnlock()
    m.mx.RLock()

    var ok bool
    value, ok = m.impl[key]
    if !ok {
        value = dflt
    }

    return
}

...
```

</p>
</details>

With a second boolean return value:

```
> carto -p foo -s MyMap -k string -v '*github.com/rs/zerolog.Logger' -b
```
<details>
<summary>Generated Source (<code>Get</code> func)</summary>
<p>

```go
...

// Get gets the *zerolog.Logger keyed by string. Also returns bool value indicating whether the key exists in the map
func (m *MyMap) Get(key string) (value *zerolog.Logger, ok bool) {
    defer m.mx.RUnlock()
    m.mx.RLock()

    value, ok = m.impl[key]

    return
}

...
```

</p>
</details>
