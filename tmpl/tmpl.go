// Code generated by /tools/tmpl.go. DO NOT EDIT.
package tmpl

/*
If you want to edit the templates directly, you can do so in
under tmpl/_gotemplate
The templates are maintained there for greater readability.
*/

// MapTmpl contains all the necessary data to generate a carto map
type MapTmpl struct {
	GenDate          string
	PackageName      string
	StructName       string
	KeyTypePackage   string
	KeyType          string
	ValueType        string
	ValueTypePackage string
	ReceiverName     string
	GetReturnsBool   bool
	LazyInstantiates bool
	GetDefault       bool
}

// HeadTmpl is the file header, including imports and struct declaration.
// If lazy map instantiation is _not_ enabled, this also wraps the New... func.
const HeadTmpl = `// Code generated by github.com/schigh/carto.  DO NOT EDIT.
package {{.PackageName}}
import (
	"sync"

{{if .KeyTypePackage}}	"{{.KeyTypePackage}}"
{{end}}{{if .ValueTypePackage}}	"{{.ValueTypePackage}}"
{{end}})

// {{.StructName}} wraps map[{{.KeyType}}]{{.ValueType}}, and locks reads and writes with a mutex
type {{.StructName}} struct {
	mx sync.RWMutex
	impl map[{{.KeyType}}]{{.ValueType}}
{{if .LazyInstantiates}}	onceToken sync.Once
{{end}}
}
{{if .LazyInstantiates}}{{else}}
// New{{.StructName}} generates a new {{.StructName}} with a non-nil map
func New{{.StructName}}() *{{.StructName}} {
	{{.ReceiverName}} := &{{.StructName}}{}
	{{.ReceiverName}}.impl = make(map[{{.KeyType}}]{{.ValueType}})

	return {{.ReceiverName}}
}
{{end}}`

// GetTmpl wraps the `Get` func
const GetTmpl = `{{if .GetDefault}}// Get gets the {{.ValueType}} keyed by {{.KeyType}}.  If the key does not exist, a default {{.ValueType}} will be returned
func ({{.ReceiverName}} *{{.StructName}}) Get(key {{.KeyType}}, dflt {{.ValueType}})(value {{.ValueType}}) {
defer {{.ReceiverName}}.mx.RUnlock()
    {{.ReceiverName}}.mx.RLock()

	var ok bool
	value, ok = {{.ReceiverName}}.impl[key]
	if !ok {
		value = dflt
	}

	return
}
{{else}}// Get gets the {{.ValueType}} keyed by {{.KeyType}}. {{if .GetReturnsBool}}Also returns bool value indicating whether the key exists in the map{{end}}
func ({{.ReceiverName}} *{{.StructName}}) Get(key {{.KeyType}}) {{if .GetReturnsBool}}(value {{.ValueType}}, ok bool){{else}}(value {{.ValueType}}){{end}} {
	defer {{.ReceiverName}}.mx.RUnlock()
    {{.ReceiverName}}.mx.RLock()

	value{{if .GetReturnsBool}}, ok{{end}} = {{.ReceiverName}}.impl[key]

	return
}
{{end}}`

// KeysTmpl wraps the `Keys` func
const KeysTmpl = `// Keys will return all keys in the {{.StructName}}'s internal map
func ({{.ReceiverName}} *{{.StructName}}) Keys() (keys []{{.KeyType}}) {
defer {{.ReceiverName}}.mx.RUnlock()
	{{.ReceiverName}}.mx.RLock()

	keys = make([]{{.KeyType}}, len({{.ReceiverName}}.impl))
	var i int
	for k := range {{.ReceiverName}}.impl {
		keys[i] = k
		i++
	}

	return
}
`

// SetTmpl wraps the `Set` func
const SetTmpl = `// Set will add an element to the {{.StructName}}'s internal map with the specified key
func ({{.ReceiverName}} *{{.StructName}}) Set(key {{.KeyType}}, value {{.ValueType}}) {
defer {{.ReceiverName}}.mx.Unlock()
	{{.ReceiverName}}.mx.Lock()

{{if .LazyInstantiates}}	{{.ReceiverName}}.onceToken.Do(func() {
		{{.ReceiverName}}.impl = make(map[{{.KeyType}}]{{.ValueType}})
	})
{{end}}	{{.ReceiverName}}.impl[key] = value
}
`

// AbsorbTmpl wraps the `Absorb` func
const AbsorbTmpl = `// Absorb will take all the keys and values from another {{.StructName}}'s internal map and
// overwrite any existing keys
func ({{.ReceiverName}} *{{.StructName}}) Absorb(otherMap *{{.StructName}}) {
	defer otherMap.mx.RUnlock()
	defer {{.ReceiverName}}.mx.Unlock()
{{.ReceiverName}}.mx.Lock()
otherMap.mx.RLock()

{{if .LazyInstantiates}}	{{.ReceiverName}}.onceToken.Do(func() {
		{{.ReceiverName}}.impl = make(map[{{.KeyType}}]{{.ValueType}})
	})
{{end}}	for k, v := range otherMap.impl {
		{{.ReceiverName}}.impl[k] = v
	}
}
`

// AbsorbMapTmpl wraps the `AbsorbMap` func
const AbsorbMapTmpl = `// AbsorbMap will take all the keys and values from another map and overwrite any existing keys
func ({{.ReceiverName}} *{{.StructName}}) AbsorbMap(regularMap map[{{.KeyType}}]{{.ValueType}}) {
defer {{.ReceiverName}}.mx.Unlock()
	{{.ReceiverName}}.mx.Lock()

{{if .LazyInstantiates}}	{{.ReceiverName}}.onceToken.Do(func() {
		{{.ReceiverName}}.impl = make(map[{{.KeyType}}]{{.ValueType}})
	})
{{end}}	for k, v := range regularMap {
		{{.ReceiverName}}.impl[k] = v
	}
}
`

// DeleteTmpl wraps the `Delete` func
const DeleteTmpl = `// Delete will remove a {{.ValueType}} from the map by key
func ({{.ReceiverName}} *{{.StructName}}) Delete(key {{.KeyType}}) {
defer {{.ReceiverName}}.mx.Unlock()
	{{.ReceiverName}}.mx.Lock()

{{if .LazyInstantiates}}    {{.ReceiverName}}.onceToken.Do(func() {
    	{{.ReceiverName}}.impl = make(map[{{.KeyType}}]{{.ValueType}})
	})
{{end}}	delete({{.ReceiverName}}.impl, key)
}
`

// ClearTmpl wraps the `Clear` func
const ClearTmpl = `// Clear will remove all elements from the map
func ({{.ReceiverName}} *{{.StructName}}) Clear() {
defer {{.ReceiverName}}.mx.Unlock()
	{{.ReceiverName}}.mx.Lock()

	{{.ReceiverName}}.impl = make(map[{{.KeyType}}]{{.ValueType}})
}
`

// ValueTmpl wraps the `Value` func
const ValueTmpl = `// Value returns a copy of the underlying map[{{.KeyType}}]{{.ValueType}}
func ({{.ReceiverName}} *{{.StructName}}) Value() map[{{.KeyType}}]{{.ValueType}} {
	defer {{.ReceiverName}}.mx.RUnlock()
{{.ReceiverName}}.mx.RLock()

	out := make(map[{{.KeyType}}]{{.ValueType}}, len({{.ReceiverName}}.impl))
	for k, v := range {{.ReceiverName}}.impl {
		out[k] = v
	}

	return out
}
`

// SizeTmpl wraps the `Size` func
const SizeTmpl = `// Size returns the number of elements in the underlying map[{{.KeyType}}]{{.ValueType}}
func ({{.ReceiverName}} *{{.StructName}}) Size() int {
	defer {{.ReceiverName}}.mx.RUnlock()
	{{.ReceiverName}}.mx.RLock()

	return len({{.ReceiverName}}.impl)
}
`

// EachTmpl wraps the `Each` func
const EachTmpl = `// Each runs a function over each key/value pair in the {{.StructName}}
// If the function returns false, the interation through the underlying
// map will halt.
// This function does not mutate the underlying map, although the values
// of the map may be mutated in place
// !!!Warning: calls to {{.ReceiverName}}.Set or {{.ReceiverName}}.Delete will deadlock !!!
func ({{.ReceiverName}} *{{.StructName}}) Each(f func(key {{.KeyType}}, value {{.ValueType}}) bool) {
	defer {{.ReceiverName}}.mx.RUnlock()
	{{.ReceiverName}}.mx.RLock()

	for _k := range {{.ReceiverName}}.impl {
		_v := {{.ReceiverName}}.impl[_k]
		if !f(_k, _v) {
			return
		}
	}
}
`
